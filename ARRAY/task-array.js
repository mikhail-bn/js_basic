
// Задание №1 ===========================================================================================

//* Представьте, что мы разрабатываем систему очередей для какого-либо заведения. Например, для почты. Для этого мы создали массив peopleWaiting, который отображает текущий статус очереди. const peopleWaiting = ['Кристина', 'Олег', 'Кирилл', 'Мария', 'Светлана', 'Артем', 'Глеб'];

//* По логике, следующую посылку по почте получит Кристина, после нее уже 1- будет Олег. Сейчас вам необходимо реализовать следующую логику в коде шаг за шагом: 1. Кристина и Олег получили посылки и ушли из очереди. Вам необходимо удалить их из массива. 2. Теперь подошла очередь к Кириллу. И неожиданно сотрудница почты говорит, что скоро у них обеденный перерыв и она успеет обслужить только Кирилла. Поэтому все остальные люди, стоящие за Кириллом, решили не ждать, когда закончится обед и просто ушли из отделения почты. Вам необходимо сначала удалить Кирилла из массива peopleWaiting, а затем удалить людей, которые не успели получить посылки. Когда какой-либо человек получает посылку, необходимо вывести в модальном окне сообщение “name получил(а) посылку. В очереди осталось length человек.” (Замените name на имя человека, получившего посылку, а length - на количество человек, которые остались в очереди). Если же человек не получил посылку и ушел из очереди, то выведите в модальном окне через alert сообщение “name не получил(а) посылку и ушел(ла) из очереди”. 

//* Рекомендуется создать 2 функции: giveParcel - для выдачи посылки и удаления клиента из начала массива, leaveQueueWithoutParcel - для удаления клиента, который не получил посылку из конца списка.

// Порядок выполнения общий: создать цикл для выбывания, создать функцию получения, создать функцию "не дождался", поместить функцию "умолчания" в тело цикла,  вызвать другую функцию n-e колво раз. 

// 1. Определить массив

// 2. Определить функцию giveParcel - получения посылки - и в теле функции определить переменную clientName и поместить в неё итерацию удаления человека с начала массива, и выводом её в alert.

// 3. Определить функцию leaveQueueWithoutParcel - уход человека из очереди без посылки - и переменной clientName передать итерацию удаления человека из очереди с конца массива, и выводом её в консоль.

// 4. Инициация и умолчание. Событие либо ухода либо получения без какого-либо условия возможно вызовом функций поочерёдно или случайным образом. Без инициации возможно поместить вызов функции в цикл перебора от длины количества массива peopleWaiting.length до 0, то есть перебрать элементы массива и каждый цикл перебора вызывать безусловную функцию. Таким образом скриат будет работать либо если вызвать обе функции  в случайном, или каком-либо порядке через цикл с условием. Также можно поместить одну любую функцию в цикл с убыванием по 'умолчанию', а другую вызывать. При этом сначала скрипт отработает вызванные функции а потом остаток удалит с конца (при условии что вызов функции будет до цикла, если же поместить цикл до вызовов функции то цикл "промотает" все элементы а при вызове функции далее будет "вызываться" undefined)

// 5. Вызвать функцию столько раз сколько будет получена посылка. Каждый вызов функции данного скрипта будет подразумевать получение посылки и соответственно удаление элемента массива с начала

// 6. Определить цикл с помещением в тело функции той либо другой

// 7. Следует заметить, что "случайный вариант" уменьшения массива тем или иным способом убытия следует реализовать вызовом той или иной функции случайным образом. Данный пример показывает частный случай условия 3 получили остальные ушли по очереди.



// const peopleWaiting = ['Кристина', 'Олег', 'Кирилл', 'Мария', 'Светлана', 'Артем', 'Глеб'];

// const giveParcel = () => {
//     const clientName = peopleWaiting.shift(); /* Помещение в переменную добавляемого С НАЧАЛА человека */
//     alert(`${clientName} получил(а) посылку. В очереди осталось ${peopleWaiting.length} человек.`); /* Длина очереди peopleWaiting.length */
// }


// const leaveQueueWithoutParcel = () => {
//     const clientName = peopleWaiting.pop(); /* Помещение в переменную удаляемого С КОНЦА человека */    
//     alert(`${clientName} не получил(а) посылку и ушел(ла) из очереди`);
// }

// giveParcel();
// giveParcel();
// giveParcel();

// /* Формирование цикла для уменьшения оставшейся очереди с конца постепенно (если надо) */

// for (let i = peopleWaiting.length; i > 0; i -= 1) {
//     leaveQueueWithoutParcel();
// }; 








// Задание #2 ===========================================================================================

//* Вам необходимо создать функцию getSumOfSequence, которая будет создавать массив из чисел и высчитывать сумму первого и последнего элементов массива. Функция принимает в себя один параметр number. Используя этот параметр, нужно создать массив из чисел от 1 до number. Для заполнения массива элементами используйте цикл for. (Например, если был передан number равный 5, то массив должен выглядеть следующим образом: [1, 2, 3, 4, 5]) Функция  getSumOfSequence  должна возвращать сумму первого и последнего элементов итогового массива. Пример:

//* getSumOfSequence(5) = 6 // [1, 2, 3, 4, 5], 1+5=6



// const getSumOfSequence = (number) => {
//     let arrayFromNumber = [];    
//     for (let i = 1; i <= number; i += 1) {       
//         arrayFromNumber.push(i);        
//     }  
//     const firstIndexOfArray = arrayFromNumber[0];   
//     const lastIndexOfArray = arrayFromNumber[arrayFromNumber.length - 1];    
//     const  sumOfTwoIndexes = Number(firstIndexOfArray) + Number(lastIndexOfArray);    
//     alert(`Сумма первого и последнего элемента массива ${arrayFromNumber} равна ${sumOfTwoIndexes}`);
// };
// getSumOfSequence(5)





// Задание #3 ============================================================================================






// Задание #4 =============================================================================================

// Задание #5 =============================================================================================

// Задание #6 =============================================================================================

// Задание #7 =============================================================================================

// Задание #8 =============================================================================================

// Задание #9 =============================================================================================

// Задание #10 =============================================================================================



 



